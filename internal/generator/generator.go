package generator

import (
	"context"
	"embed"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/aprikotdev/speckles/internal/caser"
	"github.com/aprikotdev/speckles/internal/config"
	"github.com/iancoleman/strcase"
)

//go:embed templates
var templatesFS embed.FS

var templs *template.Template

func GenerateAll(ctx context.Context, outPath string, namespaces []*config.Namespace) (err error) {
	if len(namespaces) == 0 {
		return fmt.Errorf("no namespaces specified")
	}

	files, _ := os.ReadDir(outPath)
	for _, file := range files {
		if file.Name() != "elements.go" {
			if err := os.Remove(filepath.Join(outPath, file.Name())); err != nil {
				return fmt.Errorf("failed to clean output directory: %w", err)
			}
		}
	}

	fm := template.FuncMap{}
	fm["goPascal"] = caser.GoPascal
	fm["comments"] = comments
	fm["choiceSuffix"] = config.ChoiceSuffix
	fm["attrIsBool"] = config.IsAttributeTypeBool
	fm["attrIsRune"] = config.IsAttributeTypeRune
	fm["attrIsString"] = config.IsAttributeTypeString
	fm["attrIsInt"] = config.IsAttributeTypeInt
	fm["attrIsNumber"] = config.IsAttributeTypeNumber
	fm["attrIsDelimited"] = config.IsAttributeTypeDelimited
	fm["attrIsKV"] = config.IsAttributeTypeKeyValue
	fm["attrIsChoices"] = config.IsAttributeTypeChoices

	templs, err = template.New("base").Funcs(fm).ParseFS(templatesFS, "templates/*.tmpl")
	if err != nil {
		return fmt.Errorf("failed to parse templates: %w", err)
	}

	for _, ns := range namespaces {
		for _, element := range ns.Elements {
			if err := generateElement(ctx, outPath, ns, element); err != nil {
				return fmt.Errorf("failed to generate element %s: %w", element.Tag, err)
			}
		}
	}

	return nil
}

func generateElement(_ context.Context, pkgPath string, ns *config.Namespace, element *config.Element) error {
	if element.Name == "" {
		element.Name = element.Tag
	}

	element.Attributes = processAttributes(element, ns)

	prefix := strcase.ToSnake(ns.Name)

	suffix := strcase.ToSnake(element.Tag)
	// Handle special case for h_1 to h_6
	re := regexp.MustCompile(`^h_[1-6]$`)
	if re.MatchString(suffix) {
		suffix = strings.ReplaceAll(suffix, "_", "")
	}

	filename := fmt.Sprintf("%s_%s.go", prefix, suffix)
	elementFilepath := filepath.Join(pkgPath, filename)

	f, err := os.Create(elementFilepath)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", elementFilepath, err)
	}
	defer f.Close()

	templateName := "element.go.tmpl"

	header := "// Code generated by speckles. DO NOT EDIT.\n" +
		"// Source: generator/templates/" + templateName + "\n" +
		"\n"
	if _, err := f.WriteString(header); err != nil {
		return fmt.Errorf("failed to write header: %w", err)
	}

	templateData := struct {
		Namespace *config.Namespace
		Element   *config.Element
	}{
		Namespace: ns,
		Element:   element,
	}

	if err := templs.ExecuteTemplate(f, templateName, templateData); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

func processAttributes(element *config.Element, ns *config.Namespace) []*config.Attribute {
	length := len(element.Attributes) + len(ns.Attributes)

	attrs := make([]*config.Attribute, 0, length)
	attrs = append(attrs, element.Attributes...)
	attrs = append(attrs, ns.Attributes...)

	seenKeys := make(map[string]bool)
	uniqueAttrs := make([]*config.Attribute, 0, length)

	for _, attr := range attrs {
		// Ensure both name and key are set
		if attr.Name == "" {
			attr.Name = attr.Key
		}
		if attr.Key == "" {
			attr.Key = attr.Name
		}

		// Skip duplicate attributes based on Key
		if !seenKeys[attr.Key] {
			seenKeys[attr.Key] = true
			attr.Name = caser.GoPascal(attr.Name)
			uniqueAttrs = append(uniqueAttrs, attr)
		}
	}

	return uniqueAttrs
}

func comments(s string) string {
	maxLen := 80
	lines := []string{}
	for _, row := range strings.Split(s, "\n") {
		row = strings.TrimSpace(row)
		if row == "" {
			lines = append(lines, "//")
			continue
		}
		words := strings.Fields(row)
		lineStart := "// "
		line := lineStart
		for _, word := range words {
			if len(line)+len(word) > maxLen {
				lines = append(lines, line)
				line = lineStart
			}
			line += word + " "
		}
		lines = append(lines, line)
	}
	return strings.Join(lines, "\n")
}
