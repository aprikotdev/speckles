// Code generated by speckles. DO NOT EDIT.
// Source: generator/templates/element.go.tmpl

// Package elements html input is generated from configuration file.
package elements

import (
	"fmt"
	"sort"
	"strings"

	"github.com/igrmk/treemap/v2"
)

// The HTML <input> element is used to create interactive controls for web-based
// forms in order to accept data from the user; a wide variety of types of input
// data and control widgets are available, depending on the device and user
// agent.
type InputElement struct {
	*Element
}

// Create a new InputElement element. This will create a new element
// with the tag "input" during rendering.
func Input() *InputElement {
	e := NewElement("input")
	e.isSelfClosing = true

	return &InputElement{Element: e}
}

func (e *InputElement) Children(children ...ElementRenderer) *InputElement {
	e.descendants = append(e.descendants, children...)
	return e
}

func (e *InputElement) IfChildren(condition bool, children ...ElementRenderer) *InputElement {
	if condition {
		e.descendants = append(e.descendants, children...)
	}
	return e
}

func (e *InputElement) TernChildren(condition bool, trueChildren, falseChildren ElementRenderer) *InputElement {
	if condition {
		e.descendants = append(e.descendants, trueChildren)
	} else {
		e.descendants = append(e.descendants, falseChildren)
	}
	return e
}

func (e *InputElement) BoolAttr(name string) *InputElement {
	if e.boolAttributes == nil {
		e.boolAttributes = treemap.New[string, bool]()
	}
	e.boolAttributes.Set(name, true)
	return e
}

func (e *InputElement) IfBoolAttr(condition bool, name string) *InputElement {
	if condition {
		e.BoolAttr(name)
	}
	return e
}

func (e *InputElement) Attr(name, value string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set(name, value)
	return e
}

func (e *InputElement) IfAttr(condition bool, name, value string) *InputElement {
	if condition {
		e.Attr(name, value)
	}
	return e
}

func (e *InputElement) Text(text string) *InputElement {
	e.descendants = append(e.descendants, Text(text))
	return e
}

func (e *InputElement) TextF(format string, args ...any) *InputElement {
	return e.Text(fmt.Sprintf(format, args...))
}

func (e *InputElement) IfText(condition bool, text string) *InputElement {
	if condition {
		e.descendants = append(e.descendants, Text(text))
	}
	return e
}

func (e *InputElement) IfTextF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.descendants = append(e.descendants, Text(fmt.Sprintf(format, args...)))
	}
	return e
}

func (e *InputElement) Escaped(text string) *InputElement {
	e.descendants = append(e.descendants, Escaped(text))
	return e
}

func (e *InputElement) IfEscaped(condition bool, text string) *InputElement {
	if condition {
		e.descendants = append(e.descendants, Escaped(text))
	}
	return e
}

func (e *InputElement) EscapedF(format string, args ...any) *InputElement {
	return e.Escaped(fmt.Sprintf(format, args...))
}

func (e *InputElement) IfEscapedF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.descendants = append(e.descendants, EscapedF(format, args...))
	}
	return e
}

// Hint for expected file type in file upload controls.
func (e *InputElement) Accept(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("accept", s)
	return e
}

// Hint for expected file type in file upload controls.
func (e *InputElement) AcceptF(format string, args ...any) *InputElement {
	return e.Accept(fmt.Sprintf(format, args...))
}

// Hint for expected file type in file upload controls.
func (e *InputElement) IfAccept(condition bool, s string) *InputElement {
	if condition {
		e.Accept(s)
	}
	return e
}

// Hint for expected file type in file upload controls.
func (e *InputElement) IfAcceptF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Accept(fmt.Sprintf(format, args...))
	}
	return e
}

// Hint for expected file type in file upload controls.
// Remove the attribute Accept from the element.
func (e *InputElement) AcceptRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("accept")
	return e
}

// Alternative text in case an image can't be displayed.
func (e *InputElement) Alt(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("alt", s)
	return e
}

// Alternative text in case an image can't be displayed.
func (e *InputElement) AltF(format string, args ...any) *InputElement {
	return e.Alt(fmt.Sprintf(format, args...))
}

// Alternative text in case an image can't be displayed.
func (e *InputElement) IfAlt(condition bool, s string) *InputElement {
	if condition {
		e.Alt(s)
	}
	return e
}

// Alternative text in case an image can't be displayed.
func (e *InputElement) IfAltF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Alt(fmt.Sprintf(format, args...))
	}
	return e
}

// Alternative text in case an image can't be displayed.
// Remove the attribute Alt from the element.
func (e *InputElement) AltRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("alt")
	return e
}

// Hint for form autofill feature.
func (e *InputElement) Autocomplete(c InputAutocompleteChoice) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("autocomplete", string(c))
	return e
}

type InputAutocompleteChoice string

const (
	// The browser is allowed to automatically complete the input. (Default)
	InputAutocompleteOn InputAutocompleteChoice = "on"
	// The browser must not automatically complete the input.
	InputAutocompleteOff InputAutocompleteChoice = "off"
)

// Hint for form autofill feature.
// Remove the attribute Autocomplete from the element.
func (e *InputElement) AutocompleteRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("autocomplete")
	return e
}

// Automatically focus the form control when the page is loaded.
func (e *InputElement) Autofocus() *InputElement {
	e.AutofocusSet(true)
	return e
}

// Automatically focus the form control when the page is loaded.
func (e *InputElement) IfAutofocus(condition bool) *InputElement {
	if condition {
		e.AutofocusSet(true)
	}
	return e
}

// Automatically focus the form control when the page is loaded.
// Set the attribute Autofocus to the value b explicitly.
func (e *InputElement) AutofocusSet(b bool) *InputElement {
	if e.boolAttributes == nil {
		e.boolAttributes = treemap.New[string, bool]()
	}
	e.boolAttributes.Set("autofocus", b)
	return e
}

// Automatically focus the form control when the page is loaded.
func (e *InputElement) IfSetAutofocus(condition bool, b bool) *InputElement {
	if condition {
		e.AutofocusSet(b)
	}
	return e
}

// Remove the attribute Autofocus from the element.
// Automatically focus the form control when the page is loaded.
func (e *InputElement) AutofocusRemove() *InputElement {
	if e.boolAttributes == nil {
		return e
	}
	e.boolAttributes.Del("autofocus")
	return e
}

// Whether the command or control is checked.
func (e *InputElement) Checked() *InputElement {
	e.CheckedSet(true)
	return e
}

// Whether the command or control is checked.
func (e *InputElement) IfChecked(condition bool) *InputElement {
	if condition {
		e.CheckedSet(true)
	}
	return e
}

// Whether the command or control is checked.
// Set the attribute Checked to the value b explicitly.
func (e *InputElement) CheckedSet(b bool) *InputElement {
	if e.boolAttributes == nil {
		e.boolAttributes = treemap.New[string, bool]()
	}
	e.boolAttributes.Set("checked", b)
	return e
}

// Whether the command or control is checked.
func (e *InputElement) IfSetChecked(condition bool, b bool) *InputElement {
	if condition {
		e.CheckedSet(b)
	}
	return e
}

// Remove the attribute Checked from the element.
// Whether the command or control is checked.
func (e *InputElement) CheckedRemove() *InputElement {
	if e.boolAttributes == nil {
		return e
	}
	e.boolAttributes.Del("checked")
	return e
}

// Name of form field to use for sending the element's directionality in form
// submission.
func (e *InputElement) Dirname(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("dirname", s)
	return e
}

// Name of form field to use for sending the element's directionality in form
// submission.
func (e *InputElement) DirnameF(format string, args ...any) *InputElement {
	return e.Dirname(fmt.Sprintf(format, args...))
}

// Name of form field to use for sending the element's directionality in form
// submission.
func (e *InputElement) IfDirname(condition bool, s string) *InputElement {
	if condition {
		e.Dirname(s)
	}
	return e
}

// Name of form field to use for sending the element's directionality in form
// submission.
func (e *InputElement) IfDirnameF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Dirname(fmt.Sprintf(format, args...))
	}
	return e
}

// Name of form field to use for sending the element's directionality in form
// submission.
// Remove the attribute Dirname from the element.
func (e *InputElement) DirnameRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("dirname")
	return e
}

// Whether the form control is disabled.
func (e *InputElement) Disabled() *InputElement {
	e.DisabledSet(true)
	return e
}

// Whether the form control is disabled.
func (e *InputElement) IfDisabled(condition bool) *InputElement {
	if condition {
		e.DisabledSet(true)
	}
	return e
}

// Whether the form control is disabled.
// Set the attribute Disabled to the value b explicitly.
func (e *InputElement) DisabledSet(b bool) *InputElement {
	if e.boolAttributes == nil {
		e.boolAttributes = treemap.New[string, bool]()
	}
	e.boolAttributes.Set("disabled", b)
	return e
}

// Whether the form control is disabled.
func (e *InputElement) IfSetDisabled(condition bool, b bool) *InputElement {
	if condition {
		e.DisabledSet(b)
	}
	return e
}

// Remove the attribute Disabled from the element.
// Whether the form control is disabled.
func (e *InputElement) DisabledRemove() *InputElement {
	if e.boolAttributes == nil {
		return e
	}
	e.boolAttributes.Del("disabled")
	return e
}

// Associates the control with a form element.
func (e *InputElement) Form(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("form", s)
	return e
}

// Associates the control with a form element.
func (e *InputElement) FormF(format string, args ...any) *InputElement {
	return e.Form(fmt.Sprintf(format, args...))
}

// Associates the control with a form element.
func (e *InputElement) IfForm(condition bool, s string) *InputElement {
	if condition {
		e.Form(s)
	}
	return e
}

// Associates the control with a form element.
func (e *InputElement) IfFormF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Form(fmt.Sprintf(format, args...))
	}
	return e
}

// Associates the control with a form element.
// Remove the attribute Form from the element.
func (e *InputElement) FormRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("form")
	return e
}

// URL to use for form submission.
func (e *InputElement) Formaction(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("formaction", s)
	return e
}

// URL to use for form submission.
func (e *InputElement) FormactionF(format string, args ...any) *InputElement {
	return e.Formaction(fmt.Sprintf(format, args...))
}

// URL to use for form submission.
func (e *InputElement) IfFormaction(condition bool, s string) *InputElement {
	if condition {
		e.Formaction(s)
	}
	return e
}

// URL to use for form submission.
func (e *InputElement) IfFormactionF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Formaction(fmt.Sprintf(format, args...))
	}
	return e
}

// URL to use for form submission.
// Remove the attribute Formaction from the element.
func (e *InputElement) FormactionRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("formaction")
	return e
}

// Form data set encoding type to use for form submission.
func (e *InputElement) Formenctype(c InputFormenctypeChoice) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("formenctype", string(c))
	return e
}

type InputFormenctypeChoice string

const (
	// The default value if the attribute is not specified.
	InputFormenctypeApplicationXWwwFormURLencoded InputFormenctypeChoice = "application/x-www-form-urlencoded"
	// Use this value if you are using an enctype that requires a file upload.
	InputFormenctypeMultipartFormData InputFormenctypeChoice = "multipart/form-data"
	// Use this value if you are using a "text/plain" enctype and the form will not
	// contain any file uploads.
	InputFormenctypeTextPlain InputFormenctypeChoice = "text/plain"
)

// Form data set encoding type to use for form submission.
// Remove the attribute Formenctype from the element.
func (e *InputElement) FormenctypeRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("formenctype")
	return e
}

// HTTP method to use for form submission.
func (e *InputElement) Formmethod(c InputFormmethodChoice) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("formmethod", string(c))
	return e
}

type InputFormmethodChoice string

const (
	// The data from the form is included in the body of the HTTP request when sent
	// to the server.
	InputFormmethodPost InputFormmethodChoice = "post"
	// The data from the form are appended to the form attribute URI, with a '?' as
	// a separator, and the resulting URI is sent to the server. Use this method
	// when the form has no side-effects and contains only ASCII characters.
	InputFormmethodGet InputFormmethodChoice = "get"
	// When the form is inside a <dialog>, closes the dialog on submission.
	InputFormmethodDialog InputFormmethodChoice = "dialog"
)

// HTTP method to use for form submission.
// Remove the attribute Formmethod from the element.
func (e *InputElement) FormmethodRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("formmethod")
	return e
}

// Bypass form control validation for form submission.
func (e *InputElement) Formnovalidate() *InputElement {
	e.FormnovalidateSet(true)
	return e
}

// Bypass form control validation for form submission.
func (e *InputElement) IfFormnovalidate(condition bool) *InputElement {
	if condition {
		e.FormnovalidateSet(true)
	}
	return e
}

// Bypass form control validation for form submission.
// Set the attribute Formnovalidate to the value b explicitly.
func (e *InputElement) FormnovalidateSet(b bool) *InputElement {
	if e.boolAttributes == nil {
		e.boolAttributes = treemap.New[string, bool]()
	}
	e.boolAttributes.Set("formnovalidate", b)
	return e
}

// Bypass form control validation for form submission.
func (e *InputElement) IfSetFormnovalidate(condition bool, b bool) *InputElement {
	if condition {
		e.FormnovalidateSet(b)
	}
	return e
}

// Remove the attribute Formnovalidate from the element.
// Bypass form control validation for form submission.
func (e *InputElement) FormnovalidateRemove() *InputElement {
	if e.boolAttributes == nil {
		return e
	}
	e.boolAttributes.Del("formnovalidate")
	return e
}

// Browsing context for form submission.
func (e *InputElement) Formtarget(c InputFormtargetChoice) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("formtarget", string(c))
	return e
}

type InputFormtargetChoice string

const (
	// Load the response into the same browsing context as the current one. This
	// value is the default if the attribute is not specified.
	InputFormtargetSelf InputFormtargetChoice = "_self"
	// Load the response into a new unnamed browsing context.
	InputFormtargetBlank InputFormtargetChoice = "_blank"
	// Load the response into the parent browsing context of the current one. If
	// there is no parent, this option behaves the same way as _self.
	InputFormtargetParent InputFormtargetChoice = "_parent"
	// Load the response into the top-level browsing context (that is, the browsing
	// context that is an ancestor of the current one, and has no parent). If there
	// is no parent, this option behaves the same way as _self.
	InputFormtargetTop InputFormtargetChoice = "_top"
)

// Browsing context for form submission.
// Remove the attribute Formtarget from the element.
func (e *InputElement) FormtargetRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("formtarget")
	return e
}

// Height of the image in pixels.
func (e *InputElement) Height(i int) *InputElement {
	if e.intAttributes == nil {
		e.intAttributes = treemap.New[string, int]()
	}
	e.intAttributes.Set("height", i)
	return e
}

// Height of the image in pixels.
func (e *InputElement) IfHeight(condition bool, i int) *InputElement {
	if condition {
		e.Height(i)
	}
	return e
}

// Height of the image in pixels.
// Remove the attribute Height from the element.
func (e *InputElement) HeightRemove() *InputElement {
	if e.intAttributes == nil {
		return e
	}
	e.intAttributes.Del("height")
	return e
}

// Identifies a list of pre-defined options to suggest to the user.
func (e *InputElement) List(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("list", s)
	return e
}

// Identifies a list of pre-defined options to suggest to the user.
func (e *InputElement) ListF(format string, args ...any) *InputElement {
	return e.List(fmt.Sprintf(format, args...))
}

// Identifies a list of pre-defined options to suggest to the user.
func (e *InputElement) IfList(condition bool, s string) *InputElement {
	if condition {
		e.List(s)
	}
	return e
}

// Identifies a list of pre-defined options to suggest to the user.
func (e *InputElement) IfListF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.List(fmt.Sprintf(format, args...))
	}
	return e
}

// Identifies a list of pre-defined options to suggest to the user.
// Remove the attribute List from the element.
func (e *InputElement) ListRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("list")
	return e
}

// maximum value of an <input> element with type="number" or type="range".
func (e *InputElement) MaxStr(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("max", s)
	return e
}

// maximum value of an <input> element with type="number" or type="range".
func (e *InputElement) MaxStrF(format string, args ...any) *InputElement {
	return e.MaxStr(fmt.Sprintf(format, args...))
}

// maximum value of an <input> element with type="number" or type="range".
func (e *InputElement) IfMaxStr(condition bool, s string) *InputElement {
	if condition {
		e.MaxStr(s)
	}
	return e
}

// maximum value of an <input> element with type="number" or type="range".
func (e *InputElement) IfMaxStrF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.MaxStr(fmt.Sprintf(format, args...))
	}
	return e
}

// maximum value of an <input> element with type="number" or type="range".
// Remove the attribute MaxStr from the element.
func (e *InputElement) MaxStrRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("max")
	return e
}

// maximum number of characters (as UTF-16 code units) the user can enter into
// an <input> element. This must be an integer value 0 or higher. If no
// maxlength is specified, or an invalid value is specified, the input has no
// maximum length. This value must also be greater than or equal to the value of
// minlength.
func (e *InputElement) Maxlength(i int) *InputElement {
	if e.intAttributes == nil {
		e.intAttributes = treemap.New[string, int]()
	}
	e.intAttributes.Set("maxlength", i)
	return e
}

// maximum number of characters (as UTF-16 code units) the user can enter into
// an <input> element. This must be an integer value 0 or higher. If no
// maxlength is specified, or an invalid value is specified, the input has no
// maximum length. This value must also be greater than or equal to the value of
// minlength.
func (e *InputElement) IfMaxlength(condition bool, i int) *InputElement {
	if condition {
		e.Maxlength(i)
	}
	return e
}

// maximum number of characters (as UTF-16 code units) the user can enter into
// an <input> element. This must be an integer value 0 or higher. If no
// maxlength is specified, or an invalid value is specified, the input has no
// maximum length. This value must also be greater than or equal to the value of
// minlength.
// Remove the attribute Maxlength from the element.
func (e *InputElement) MaxlengthRemove() *InputElement {
	if e.intAttributes == nil {
		return e
	}
	e.intAttributes.Del("maxlength")
	return e
}

// the minimum value of an <input> element with type="number" or type="range".
func (e *InputElement) MinStr(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("min", s)
	return e
}

// the minimum value of an <input> element with type="number" or type="range".
func (e *InputElement) MinStrF(format string, args ...any) *InputElement {
	return e.MinStr(fmt.Sprintf(format, args...))
}

// the minimum value of an <input> element with type="number" or type="range".
func (e *InputElement) IfMinStr(condition bool, s string) *InputElement {
	if condition {
		e.MinStr(s)
	}
	return e
}

// the minimum value of an <input> element with type="number" or type="range".
func (e *InputElement) IfMinStrF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.MinStr(fmt.Sprintf(format, args...))
	}
	return e
}

// the minimum value of an <input> element with type="number" or type="range".
// Remove the attribute MinStr from the element.
func (e *InputElement) MinStrRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("min")
	return e
}

// the minimum number of characters (as UTF-16 code units) the user can enter
// into an <input> or <textarea> element. This must be an integer value 0 or
// higher. If no minlength is specified, or an invalid value is specified, the
// <input> or <textarea> has no minimum length. This value must also be less
// than or equal to the value of maxlength.
func (e *InputElement) Minlength(i int) *InputElement {
	if e.intAttributes == nil {
		e.intAttributes = treemap.New[string, int]()
	}
	e.intAttributes.Set("minlength", i)
	return e
}

// the minimum number of characters (as UTF-16 code units) the user can enter
// into an <input> or <textarea> element. This must be an integer value 0 or
// higher. If no minlength is specified, or an invalid value is specified, the
// <input> or <textarea> has no minimum length. This value must also be less
// than or equal to the value of maxlength.
func (e *InputElement) IfMinlength(condition bool, i int) *InputElement {
	if condition {
		e.Minlength(i)
	}
	return e
}

// the minimum number of characters (as UTF-16 code units) the user can enter
// into an <input> or <textarea> element. This must be an integer value 0 or
// higher. If no minlength is specified, or an invalid value is specified, the
// <input> or <textarea> has no minimum length. This value must also be less
// than or equal to the value of maxlength.
// Remove the attribute Minlength from the element.
func (e *InputElement) MinlengthRemove() *InputElement {
	if e.intAttributes == nil {
		return e
	}
	e.intAttributes.Del("minlength")
	return e
}

// Whether to allow multiple values.
func (e *InputElement) Multiple() *InputElement {
	e.MultipleSet(true)
	return e
}

// Whether to allow multiple values.
func (e *InputElement) IfMultiple(condition bool) *InputElement {
	if condition {
		e.MultipleSet(true)
	}
	return e
}

// Whether to allow multiple values.
// Set the attribute Multiple to the value b explicitly.
func (e *InputElement) MultipleSet(b bool) *InputElement {
	if e.boolAttributes == nil {
		e.boolAttributes = treemap.New[string, bool]()
	}
	e.boolAttributes.Set("multiple", b)
	return e
}

// Whether to allow multiple values.
func (e *InputElement) IfSetMultiple(condition bool, b bool) *InputElement {
	if condition {
		e.MultipleSet(b)
	}
	return e
}

// Remove the attribute Multiple from the element.
// Whether to allow multiple values.
func (e *InputElement) MultipleRemove() *InputElement {
	if e.boolAttributes == nil {
		return e
	}
	e.boolAttributes.Del("multiple")
	return e
}

// Name of the element to use for form submission and in the form.elements API.
func (e *InputElement) Name(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("name", s)
	return e
}

// Name of the element to use for form submission and in the form.elements API.
func (e *InputElement) NameF(format string, args ...any) *InputElement {
	return e.Name(fmt.Sprintf(format, args...))
}

// Name of the element to use for form submission and in the form.elements API.
func (e *InputElement) IfName(condition bool, s string) *InputElement {
	if condition {
		e.Name(s)
	}
	return e
}

// Name of the element to use for form submission and in the form.elements API.
func (e *InputElement) IfNameF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Name(fmt.Sprintf(format, args...))
	}
	return e
}

// Name of the element to use for form submission and in the form.elements API.
// Remove the attribute Name from the element.
func (e *InputElement) NameRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("name")
	return e
}

// Pattern to be matched by the form control's value.
func (e *InputElement) Pattern(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("pattern", s)
	return e
}

// Pattern to be matched by the form control's value.
func (e *InputElement) PatternF(format string, args ...any) *InputElement {
	return e.Pattern(fmt.Sprintf(format, args...))
}

// Pattern to be matched by the form control's value.
func (e *InputElement) IfPattern(condition bool, s string) *InputElement {
	if condition {
		e.Pattern(s)
	}
	return e
}

// Pattern to be matched by the form control's value.
func (e *InputElement) IfPatternF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Pattern(fmt.Sprintf(format, args...))
	}
	return e
}

// Pattern to be matched by the form control's value.
// Remove the attribute Pattern from the element.
func (e *InputElement) PatternRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("pattern")
	return e
}

// User-visible label to be placed within the form control.
func (e *InputElement) Placeholder(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("placeholder", s)
	return e
}

// User-visible label to be placed within the form control.
func (e *InputElement) PlaceholderF(format string, args ...any) *InputElement {
	return e.Placeholder(fmt.Sprintf(format, args...))
}

// User-visible label to be placed within the form control.
func (e *InputElement) IfPlaceholder(condition bool, s string) *InputElement {
	if condition {
		e.Placeholder(s)
	}
	return e
}

// User-visible label to be placed within the form control.
func (e *InputElement) IfPlaceholderF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Placeholder(fmt.Sprintf(format, args...))
	}
	return e
}

// User-visible label to be placed within the form control.
// Remove the attribute Placeholder from the element.
func (e *InputElement) PlaceholderRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("placeholder")
	return e
}

// Whether to allow the value to be edited by the user.
func (e *InputElement) Readonly() *InputElement {
	e.ReadonlySet(true)
	return e
}

// Whether to allow the value to be edited by the user.
func (e *InputElement) IfReadonly(condition bool) *InputElement {
	if condition {
		e.ReadonlySet(true)
	}
	return e
}

// Whether to allow the value to be edited by the user.
// Set the attribute Readonly to the value b explicitly.
func (e *InputElement) ReadonlySet(b bool) *InputElement {
	if e.boolAttributes == nil {
		e.boolAttributes = treemap.New[string, bool]()
	}
	e.boolAttributes.Set("readonly", b)
	return e
}

// Whether to allow the value to be edited by the user.
func (e *InputElement) IfSetReadonly(condition bool, b bool) *InputElement {
	if condition {
		e.ReadonlySet(b)
	}
	return e
}

// Remove the attribute Readonly from the element.
// Whether to allow the value to be edited by the user.
func (e *InputElement) ReadonlyRemove() *InputElement {
	if e.boolAttributes == nil {
		return e
	}
	e.boolAttributes.Del("readonly")
	return e
}

// Whether the control is required for form submission.
func (e *InputElement) Required() *InputElement {
	e.RequiredSet(true)
	return e
}

// Whether the control is required for form submission.
func (e *InputElement) IfRequired(condition bool) *InputElement {
	if condition {
		e.RequiredSet(true)
	}
	return e
}

// Whether the control is required for form submission.
// Set the attribute Required to the value b explicitly.
func (e *InputElement) RequiredSet(b bool) *InputElement {
	if e.boolAttributes == nil {
		e.boolAttributes = treemap.New[string, bool]()
	}
	e.boolAttributes.Set("required", b)
	return e
}

// Whether the control is required for form submission.
func (e *InputElement) IfSetRequired(condition bool, b bool) *InputElement {
	if condition {
		e.RequiredSet(b)
	}
	return e
}

// Remove the attribute Required from the element.
// Whether the control is required for form submission.
func (e *InputElement) RequiredRemove() *InputElement {
	if e.boolAttributes == nil {
		return e
	}
	e.boolAttributes.Del("required")
	return e
}

// Size of the control.
func (e *InputElement) Size(i int) *InputElement {
	if e.intAttributes == nil {
		e.intAttributes = treemap.New[string, int]()
	}
	e.intAttributes.Set("size", i)
	return e
}

// Size of the control.
func (e *InputElement) IfSize(condition bool, i int) *InputElement {
	if condition {
		e.Size(i)
	}
	return e
}

// Size of the control.
// Remove the attribute Size from the element.
func (e *InputElement) SizeRemove() *InputElement {
	if e.intAttributes == nil {
		return e
	}
	e.intAttributes.Del("size")
	return e
}

// Address of the resource.
func (e *InputElement) Src(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("src", s)
	return e
}

// Address of the resource.
func (e *InputElement) SrcF(format string, args ...any) *InputElement {
	return e.Src(fmt.Sprintf(format, args...))
}

// Address of the resource.
func (e *InputElement) IfSrc(condition bool, s string) *InputElement {
	if condition {
		e.Src(s)
	}
	return e
}

// Address of the resource.
func (e *InputElement) IfSrcF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Src(fmt.Sprintf(format, args...))
	}
	return e
}

// Address of the resource.
// Remove the attribute Src from the element.
func (e *InputElement) SrcRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("src")
	return e
}

// Granularity to be matched by the form control's value.
func (e *InputElement) Step(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("step", s)
	return e
}

// Granularity to be matched by the form control's value.
func (e *InputElement) StepF(format string, args ...any) *InputElement {
	return e.Step(fmt.Sprintf(format, args...))
}

// Granularity to be matched by the form control's value.
func (e *InputElement) IfStep(condition bool, s string) *InputElement {
	if condition {
		e.Step(s)
	}
	return e
}

// Granularity to be matched by the form control's value.
func (e *InputElement) IfStepF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Step(fmt.Sprintf(format, args...))
	}
	return e
}

// Granularity to be matched by the form control's value.
// Remove the attribute Step from the element.
func (e *InputElement) StepRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("step")
	return e
}

// Type of form control.
func (e *InputElement) Type(c InputTypeChoice) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("type", string(c))
	return e
}

type InputTypeChoice string

const (
	// A push button with no default behavior.
	InputTypeButton InputTypeChoice = "button"
	// A check box allowing single values to be selected/deselected.
	InputTypeCheckbox InputTypeChoice = "checkbox"
	// A control for specifying a color. A color picker's UI has no required
	// features other than accepting simple colors as text (more info).
	InputTypeColor InputTypeChoice = "color"
	// A control for entering a date (year, month, and day, with no time).
	InputTypeDate InputTypeChoice = "date"
	// A control for entering a date and time, with no time zone.
	InputTypeDatetimeLocal InputTypeChoice = "datetime-local"
	// A field for editing an e-mail address.
	InputTypeEmail InputTypeChoice = "email"
	// A control that lets the user select a file. Use the accept attribute to
	// define the types of files that the control can select.
	InputTypeFile InputTypeChoice = "file"
	// A control that is not displayed but whose value is submitted to the server.
	InputTypeHidden InputTypeChoice = "hidden"
	// A graphical submit button. You must use the src attribute to define the
	// source of the image and the alt attribute to define alternative text.
	InputTypeImage InputTypeChoice = "image"
	// A control for entering a month and year, with no time zone.
	InputTypeMonth InputTypeChoice = "month"
	// A control for entering a number.
	InputTypeNumber InputTypeChoice = "number"
	// A single-line text field whose value is obscured. Use the maxlength and
	// minlength attributes to specify the maximum length of the value that can be
	// entered.
	InputTypePassword InputTypeChoice = "password"
	// A radio button, allowing a single value to be selected out of multiple
	// choices with the same name value.
	InputTypeRadio InputTypeChoice = "radio"
	// A control for entering a number whose exact value is not important.
	InputTypeRange InputTypeChoice = "range"
	// A button that resets the contents of the form to default values.
	InputTypeReset InputTypeChoice = "reset"
	// A single-line text field for entering search strings. Line-breaks are
	// automatically removed from the input value.
	InputTypeSearch InputTypeChoice = "search"
	// A button that submits the form.
	InputTypeSubmit InputTypeChoice = "submit"
	// A control for entering a telephone number.
	InputTypeTel InputTypeChoice = "tel"
	// A single-line text field. Line-breaks are automatically removed from the
	// input value.
	InputTypeText InputTypeChoice = "text"
	// A control for entering a time value with no time zone.
	InputTypeTime InputTypeChoice = "time"
	// A field for entering a URL.
	InputTypeURL InputTypeChoice = "url"
	// A control for entering a date consisting of a week-year number and a week
	// number with no time zone.
	InputTypeWeek InputTypeChoice = "week"
)

// Type of form control.
// Remove the attribute Type from the element.
func (e *InputElement) TypeRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("type")
	return e
}

// Value of the form control.
func (e *InputElement) Value(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("value", s)
	return e
}

// Value of the form control.
func (e *InputElement) ValueF(format string, args ...any) *InputElement {
	return e.Value(fmt.Sprintf(format, args...))
}

// Value of the form control.
func (e *InputElement) IfValue(condition bool, s string) *InputElement {
	if condition {
		e.Value(s)
	}
	return e
}

// Value of the form control.
func (e *InputElement) IfValueF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Value(fmt.Sprintf(format, args...))
	}
	return e
}

// Value of the form control.
// Remove the attribute Value from the element.
func (e *InputElement) ValueRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("value")
	return e
}

// Width of the image in pixels.
func (e *InputElement) Width(i int) *InputElement {
	if e.intAttributes == nil {
		e.intAttributes = treemap.New[string, int]()
	}
	e.intAttributes.Set("width", i)
	return e
}

// Width of the image in pixels.
func (e *InputElement) IfWidth(condition bool, i int) *InputElement {
	if condition {
		e.Width(i)
	}
	return e
}

// Width of the image in pixels.
// Remove the attribute Width from the element.
func (e *InputElement) WidthRemove() *InputElement {
	if e.intAttributes == nil {
		return e
	}
	e.intAttributes.Del("width")
	return e
}

// The accesskey global Attribute provides a hint for generating a keyboard
// shortcut for the current element. The attribute value must consist of a
// single printable character (which includes accented and other characters that
// can be generated by the keyboard).
func (e *InputElement) Accesskey(r rune) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("accesskey", string(r))
	return e
}

// The accesskey global Attribute provides a hint for generating a keyboard
// shortcut for the current element. The attribute value must consist of a
// single printable character (which includes accented and other characters that
// can be generated by the keyboard).
func (e *InputElement) IfAccesskey(condition bool, r rune) *InputElement {
	if condition {
		e.Accesskey(r)
	}
	return e
}

// The accesskey global Attribute provides a hint for generating a keyboard
// shortcut for the current element. The attribute value must consist of a
// single printable character (which includes accented and other characters that
// can be generated by the keyboard).
// Remove the attribute Accesskey from the element.
func (e *InputElement) AccesskeyRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("accesskey")
	return e
}

// The autocapitalize global Attribute is an enumerated attribute that controls
// whether and how text input is automatically capitalized as it is
// entered/edited by the user. autocapitalize can be set on <input> and
// <textarea> elements, and on their containing <form> elements. When
// autocapitalize is set on a <form> element, it sets the autocapitalize
// behavior for all contained <input>s and <textarea>s, overriding any
// autocapitalize values set on contained elements. autocapitalize has no effect
// on the url, email, or password <input> types, where autocapitalization is
// never enabled. Where autocapitalize is not specified, the adopted default
// behavior varies between browsers. For example: Chrome and Safari default to
// on/sentences Firefox defaults to off/none.
func (e *InputElement) Autocapitalize(c InputAutocapitalizeChoice) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("autocapitalize", string(c))
	return e
}

type InputAutocapitalizeChoice string

const (
	// Do not automatically capitalize any text.
	InputAutocapitalizeOff InputAutocapitalizeChoice = "off"
	// Do not automatically capitalize any text.
	InputAutocapitalizeNone InputAutocapitalizeChoice = "none"
	// Automatically capitalize the first character of each sentence.
	InputAutocapitalizeSentences InputAutocapitalizeChoice = "sentences"
	// Automatically capitalize the first character of each sentence.
	InputAutocapitalizeOn InputAutocapitalizeChoice = "on"
	// Automatically capitalize the first character of each word.
	InputAutocapitalizeWords InputAutocapitalizeChoice = "words"
	// Automatically capitalize all characters.
	InputAutocapitalizeCharacters InputAutocapitalizeChoice = "characters"
)

// The autocapitalize global Attribute is an enumerated attribute that controls
// whether and how text input is automatically capitalized as it is
// entered/edited by the user. autocapitalize can be set on <input> and
// <textarea> elements, and on their containing <form> elements. When
// autocapitalize is set on a <form> element, it sets the autocapitalize
// behavior for all contained <input>s and <textarea>s, overriding any
// autocapitalize values set on contained elements. autocapitalize has no effect
// on the url, email, or password <input> types, where autocapitalization is
// never enabled. Where autocapitalize is not specified, the adopted default
// behavior varies between browsers. For example: Chrome and Safari default to
// on/sentences Firefox defaults to off/none.
// Remove the attribute Autocapitalize from the element.
func (e *InputElement) AutocapitalizeRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("autocapitalize")
	return e
}

// The class global Attribute is a space-separated list of the case-sensitive
// classes of the element. Classes allow CSS and JavaScript to select and access
// specific elements via the class selectors or functions like the DOM method
// document.getElementsByClassName.
func (e *InputElement) Class(s string) *InputElement {
	values := strings.Split(s, " ")
	if e.delimitedStrings == nil {
		e.delimitedStrings = treemap.New[string, *delimitedBuilder[string]]()
	}
	ds, ok := e.delimitedStrings.Get("class")
	if !ok {
		ds = newDelimitedBuilder[string](" ")
		e.delimitedStrings.Set("class", ds)
	}
	ds.Add(values...)
	return e
}

// The class global Attribute is a space-separated list of the case-sensitive
// classes of the element. Classes allow CSS and JavaScript to select and access
// specific elements via the class selectors or functions like the DOM method
// document.getElementsByClassName.
func (e *InputElement) IfClass(condition bool, s string) *InputElement {
	if condition {
		e.Class(s)
	}
	return e
}

// The class global Attribute is a space-separated list of the case-sensitive
// classes of the element. Classes allow CSS and JavaScript to select and access
// specific elements via the class selectors or functions like the DOM method
// document.getElementsByClassName.
// Remove the values from the attribute Class in the element.
func (e *InputElement) ClassRemove(s ...string) *InputElement {
	if e.delimitedStrings == nil {
		return e
	}
	ds, ok := e.delimitedStrings.Get("class")
	if !ok {
		return e
	}
	ds.Remove(s...)
	return e
}

// The contenteditable global Attribute is an enumerated attribute indicating if
// the element should be editable by the user. If so, the browser modifies its
// widget to allow editing.
func (e *InputElement) Contenteditable(c InputContenteditableChoice) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("contenteditable", string(c))
	return e
}

type InputContenteditableChoice string

const (
	// The element is editable.
	InputContenteditableEmpty InputContenteditableChoice = ""
	// The element is editable.
	InputContenteditableTrue InputContenteditableChoice = "true"
	// The element is not editable.
	InputContenteditableFalse InputContenteditableChoice = "false"
	// which indicates that the element's raw text is editable, but rich text
	// formatting is disabled.
	InputContenteditablePlaintextOnly InputContenteditableChoice = "plaintext-only"
)

// The contenteditable global Attribute is an enumerated attribute indicating if
// the element should be editable by the user. If so, the browser modifies its
// widget to allow editing.
// Remove the attribute Contenteditable from the element.
func (e *InputElement) ContenteditableRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("contenteditable")
	return e
}

// The dir global Attribute is an enumerated attribute that indicates the
// directionality of the element's text. Note: This attribute is mandatory for
// the <bdo> element where it has a different semantic meaning. This attribute
// is not inherited by the <bdi> element. If not set, its value is auto. This
// attribute can be overridden by the CSS properties direction and unicode-bidi,
// if a CSS page is active and the element supports these properties. As the
// directionality of the text is semantically related to its content and not to
// its presentation, it is recommended that web developers use this attribute
// instead of the related CSS properties when possible. That way, the text will
// display correctly even on a browser that doesn't support CSS or has the CSS
// deactivated. The auto value should be used for data with an unknown
// directionality, like data coming from user input, eventually stored in a
// database.
func (e *InputElement) Dir(c InputDirChoice) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("dir", string(c))
	return e
}

type InputDirChoice string

const (
	// which means left to right and is to be used for languages that are written
	// from the left to the right (like English);
	InputDirLtr InputDirChoice = "ltr"
	// which means right to left and is to be used for languages that are written
	// from the right to the left (like Arabic);
	InputDirRtl InputDirChoice = "rtl"
	// which lets the user agent decide. It uses a basic algorithm as it parses the
	// characters inside the element until it finds a character with a strong
	// directionality, then it applies that directionality to the whole element.
	InputDirAuto InputDirChoice = "auto"
)

// The dir global Attribute is an enumerated attribute that indicates the
// directionality of the element's text. Note: This attribute is mandatory for
// the <bdo> element where it has a different semantic meaning. This attribute
// is not inherited by the <bdi> element. If not set, its value is auto. This
// attribute can be overridden by the CSS properties direction and unicode-bidi,
// if a CSS page is active and the element supports these properties. As the
// directionality of the text is semantically related to its content and not to
// its presentation, it is recommended that web developers use this attribute
// instead of the related CSS properties when possible. That way, the text will
// display correctly even on a browser that doesn't support CSS or has the CSS
// deactivated. The auto value should be used for data with an unknown
// directionality, like data coming from user input, eventually stored in a
// database.
// Remove the attribute Dir from the element.
func (e *InputElement) DirRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("dir")
	return e
}

// The draggable global Attribute is an enumerated attribute that indicates
// whether the element can be dragged, either with native browser behavior or
// the HTML Drag and Drop API.
func (e *InputElement) Draggable(c InputDraggableChoice) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("draggable", string(c))
	return e
}

type InputDraggableChoice string

const (
	// The element is draggable.
	InputDraggableTrue InputDraggableChoice = "true"
	// The element is not draggable.
	InputDraggableFalse InputDraggableChoice = "false"
	// drag behavior is the default browser behavior: only text selections, images,
	// and links can be dragged. For other elements, the event ondragstart must be
	// set for drag and drop to work
	InputDraggableEmpty InputDraggableChoice = ""
	// drag behavior is the default browser behavior: only text selections, images,
	// and links can be dragged. For other elements, the event ondragstart must be
	// set for drag and drop to work
	InputDraggableAuto InputDraggableChoice = "auto"
)

// The draggable global Attribute is an enumerated attribute that indicates
// whether the element can be dragged, either with native browser behavior or
// the HTML Drag and Drop API.
// Remove the attribute Draggable from the element.
func (e *InputElement) DraggableRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("draggable")
	return e
}

// The enterkeyhint global Attribute is an enumerated attribute defining what
// action label (or icon) to present for the enter key on virtual keyboards.
func (e *InputElement) Enterkeyhint(c InputEnterkeyhintChoice) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("enterkeyhint", string(c))
	return e
}

type InputEnterkeyhintChoice string

const (
	// Typically inserting a new line.
	InputEnterkeyhintEnter InputEnterkeyhintChoice = "enter"
	// Typically meaning there is nothing more to input and the input method editor
	// (IME) will be closed.
	InputEnterkeyhintDone InputEnterkeyhintChoice = "done"
	// Typically meaning to take the user to the target of the text they typed.
	InputEnterkeyhintGo InputEnterkeyhintChoice = "go"
	// Typically meaning to take the user to the next field that will accept text.
	InputEnterkeyhintNext InputEnterkeyhintChoice = "next"
	// Typically meaning to take the user to the previous field that will accept
	// text.
	InputEnterkeyhintPrevious InputEnterkeyhintChoice = "previous"
	// Typically taking the user to the results of searching for the text they have
	// typed.
	InputEnterkeyhintSearch InputEnterkeyhintChoice = "search"
	// Typically delivering the text to its target.
	InputEnterkeyhintSend InputEnterkeyhintChoice = "send"
)

// The enterkeyhint global Attribute is an enumerated attribute defining what
// action label (or icon) to present for the enter key on virtual keyboards.
// Remove the attribute Enterkeyhint from the element.
func (e *InputElement) EnterkeyhintRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("enterkeyhint")
	return e
}

// The exportparts global Attribute allows you to select and style elements
// existing in nested shadow trees, by exporting their part names. The shadow
// tree is an isolated structure where identifiers, classes, and styles cannot
// be reached by selectors or queries belonging to a regular DOM. To apply a
// style to an element living in a shadow tree, by CSS rule created outside of
// it, part global attribute has to be used. It has to be assigned to an element
// present in Shadow Tree, and its value should be some identifier. Rules
// present outside of the shadow tree, must use the ::part pseudo-element,
// containing the same identifier as the argument. The global attribute part
// makes the element visible on just a single level of depth. When the shadow
// tree is nested, parts will be visible only to the parent of the shadow tree
// but not to its ancestor. Exporting parts further down is exactly what
// exportparts attribute is for. Attribute exportparts must be placed on a
// shadow Host, which is the element to which the shadow tree is attached. The
// value of the attribute should be a comma-separated list of part names present
// in the shadow tree and which should be made available via a DOM outside of
// the current structure.
func (e *InputElement) Exportparts(s string) *InputElement {
	values := strings.Split(s, ",")
	if e.delimitedStrings == nil {
		e.delimitedStrings = treemap.New[string, *delimitedBuilder[string]]()
	}
	ds, ok := e.delimitedStrings.Get("exportparts")
	if !ok {
		ds = newDelimitedBuilder[string](",")
		e.delimitedStrings.Set("exportparts", ds)
	}
	ds.Add(values...)
	return e
}

// The exportparts global Attribute allows you to select and style elements
// existing in nested shadow trees, by exporting their part names. The shadow
// tree is an isolated structure where identifiers, classes, and styles cannot
// be reached by selectors or queries belonging to a regular DOM. To apply a
// style to an element living in a shadow tree, by CSS rule created outside of
// it, part global attribute has to be used. It has to be assigned to an element
// present in Shadow Tree, and its value should be some identifier. Rules
// present outside of the shadow tree, must use the ::part pseudo-element,
// containing the same identifier as the argument. The global attribute part
// makes the element visible on just a single level of depth. When the shadow
// tree is nested, parts will be visible only to the parent of the shadow tree
// but not to its ancestor. Exporting parts further down is exactly what
// exportparts attribute is for. Attribute exportparts must be placed on a
// shadow Host, which is the element to which the shadow tree is attached. The
// value of the attribute should be a comma-separated list of part names present
// in the shadow tree and which should be made available via a DOM outside of
// the current structure.
func (e *InputElement) IfExportparts(condition bool, s string) *InputElement {
	if condition {
		e.Exportparts(s)
	}
	return e
}

// The exportparts global Attribute allows you to select and style elements
// existing in nested shadow trees, by exporting their part names. The shadow
// tree is an isolated structure where identifiers, classes, and styles cannot
// be reached by selectors or queries belonging to a regular DOM. To apply a
// style to an element living in a shadow tree, by CSS rule created outside of
// it, part global attribute has to be used. It has to be assigned to an element
// present in Shadow Tree, and its value should be some identifier. Rules
// present outside of the shadow tree, must use the ::part pseudo-element,
// containing the same identifier as the argument. The global attribute part
// makes the element visible on just a single level of depth. When the shadow
// tree is nested, parts will be visible only to the parent of the shadow tree
// but not to its ancestor. Exporting parts further down is exactly what
// exportparts attribute is for. Attribute exportparts must be placed on a
// shadow Host, which is the element to which the shadow tree is attached. The
// value of the attribute should be a comma-separated list of part names present
// in the shadow tree and which should be made available via a DOM outside of
// the current structure.
// Remove the values from the attribute Exportparts in the element.
func (e *InputElement) ExportpartsRemove(s ...string) *InputElement {
	if e.delimitedStrings == nil {
		return e
	}
	ds, ok := e.delimitedStrings.Get("exportparts")
	if !ok {
		return e
	}
	ds.Remove(s...)
	return e
}

// The hidden global Attribute is a Boolean attribute indicating that the
// element is not yet, or is no longer, relevant. For example, it can be used to
// hide elements of the page that can't be used until the login process has been
// completed. Note that browsers typically implement hidden until found using
// content-visibility: hidden. This means that unlike elements in the hidden
// state, elements in the hidden until found state will have generated boxes,
// meaning that: the element will participate in page layout margin, borders,
// padding, and background for the element will be rendered. Also, the element
// needs to be affected by layout containment in order to be revealed. This
// means that if the element in the hidden until found state has a display value
// of none, contents, or inline, then the element will not be revealed by find
// in page or fragment navigation.
func (e *InputElement) Hidden(c InputHiddenChoice) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("hidden", string(c))
	return e
}

type InputHiddenChoice string

const (
	// set the element to the hidden state. Additionally, invalid values set the
	// element to the hidden state.
	InputHiddenEmpty InputHiddenChoice = ""
	// set the element to the hidden state. Additionally, invalid values set the
	// element to the hidden state.
	InputHiddenHidden InputHiddenChoice = "hidden"
	// the element is hidden but its content will be accessible to the browser's
	// "find in page" feature or to fragment navigation. When these features cause a
	// scroll to an element in a hidden until found subtree, the browser will fire a
	// beforematch event on the hidden element remove the hidden attribute from the
	// element scroll to the element
	//
	InputHiddenUntilFound InputHiddenChoice = "until-found"
)

// The hidden global Attribute is a Boolean attribute indicating that the
// element is not yet, or is no longer, relevant. For example, it can be used to
// hide elements of the page that can't be used until the login process has been
// completed. Note that browsers typically implement hidden until found using
// content-visibility: hidden. This means that unlike elements in the hidden
// state, elements in the hidden until found state will have generated boxes,
// meaning that: the element will participate in page layout margin, borders,
// padding, and background for the element will be rendered. Also, the element
// needs to be affected by layout containment in order to be revealed. This
// means that if the element in the hidden until found state has a display value
// of none, contents, or inline, then the element will not be revealed by find
// in page or fragment navigation.
// Remove the attribute Hidden from the element.
func (e *InputElement) HiddenRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("hidden")
	return e
}

// The id global Attribute defines a unique identifier (ID) which must be unique
// in the whole document. Its purpose is to identify the element when linking
// (using a fragment identifier), scripting, or styling (with CSS).
func (e *InputElement) ID(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("id", s)
	return e
}

// The id global Attribute defines a unique identifier (ID) which must be unique
// in the whole document. Its purpose is to identify the element when linking
// (using a fragment identifier), scripting, or styling (with CSS).
func (e *InputElement) IDF(format string, args ...any) *InputElement {
	return e.ID(fmt.Sprintf(format, args...))
}

// The id global Attribute defines a unique identifier (ID) which must be unique
// in the whole document. Its purpose is to identify the element when linking
// (using a fragment identifier), scripting, or styling (with CSS).
func (e *InputElement) IfID(condition bool, s string) *InputElement {
	if condition {
		e.ID(s)
	}
	return e
}

// The id global Attribute defines a unique identifier (ID) which must be unique
// in the whole document. Its purpose is to identify the element when linking
// (using a fragment identifier), scripting, or styling (with CSS).
func (e *InputElement) IfIDF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.ID(fmt.Sprintf(format, args...))
	}
	return e
}

// The id global Attribute defines a unique identifier (ID) which must be unique
// in the whole document. Its purpose is to identify the element when linking
// (using a fragment identifier), scripting, or styling (with CSS).
// Remove the attribute ID from the element.
func (e *InputElement) IDRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("id")
	return e
}

// The inert global Attribute is a Boolean attribute indicating that the browser
// will ignore the element. With the inert attribute, all of the element's flat
// tree descendants (such as modal <dialog>s) that don't otherwise escape
// inertness are ignored. The inert attribute also makes the browser ignore
// input events sent by the user, including focus-related events and events from
// assistive technologies. Specifically, inert does the following: Prevents the
// click event from being fired when the user clicks on the element. Prevents
// the focus event from being raised by preventing the element from gaining
// focus. Hides the element and its content from assistive technologies by
// excluding them from the accessibility tree.
func (e *InputElement) Inert() *InputElement {
	e.InertSet(true)
	return e
}

// The inert global Attribute is a Boolean attribute indicating that the browser
// will ignore the element. With the inert attribute, all of the element's flat
// tree descendants (such as modal <dialog>s) that don't otherwise escape
// inertness are ignored. The inert attribute also makes the browser ignore
// input events sent by the user, including focus-related events and events from
// assistive technologies. Specifically, inert does the following: Prevents the
// click event from being fired when the user clicks on the element. Prevents
// the focus event from being raised by preventing the element from gaining
// focus. Hides the element and its content from assistive technologies by
// excluding them from the accessibility tree.
func (e *InputElement) IfInert(condition bool) *InputElement {
	if condition {
		e.InertSet(true)
	}
	return e
}

// The inert global Attribute is a Boolean attribute indicating that the browser
// will ignore the element. With the inert attribute, all of the element's flat
// tree descendants (such as modal <dialog>s) that don't otherwise escape
// inertness are ignored. The inert attribute also makes the browser ignore
// input events sent by the user, including focus-related events and events from
// assistive technologies. Specifically, inert does the following: Prevents the
// click event from being fired when the user clicks on the element. Prevents
// the focus event from being raised by preventing the element from gaining
// focus. Hides the element and its content from assistive technologies by
// excluding them from the accessibility tree.
// Set the attribute Inert to the value b explicitly.
func (e *InputElement) InertSet(b bool) *InputElement {
	if e.boolAttributes == nil {
		e.boolAttributes = treemap.New[string, bool]()
	}
	e.boolAttributes.Set("inert", b)
	return e
}

// The inert global Attribute is a Boolean attribute indicating that the browser
// will ignore the element. With the inert attribute, all of the element's flat
// tree descendants (such as modal <dialog>s) that don't otherwise escape
// inertness are ignored. The inert attribute also makes the browser ignore
// input events sent by the user, including focus-related events and events from
// assistive technologies. Specifically, inert does the following: Prevents the
// click event from being fired when the user clicks on the element. Prevents
// the focus event from being raised by preventing the element from gaining
// focus. Hides the element and its content from assistive technologies by
// excluding them from the accessibility tree.
func (e *InputElement) IfSetInert(condition bool, b bool) *InputElement {
	if condition {
		e.InertSet(b)
	}
	return e
}

// Remove the attribute Inert from the element.
// The inert global Attribute is a Boolean attribute indicating that the browser
// will ignore the element. With the inert attribute, all of the element's flat
// tree descendants (such as modal <dialog>s) that don't otherwise escape
// inertness are ignored. The inert attribute also makes the browser ignore
// input events sent by the user, including focus-related events and events from
// assistive technologies. Specifically, inert does the following: Prevents the
// click event from being fired when the user clicks on the element. Prevents
// the focus event from being raised by preventing the element from gaining
// focus. Hides the element and its content from assistive technologies by
// excluding them from the accessibility tree.
func (e *InputElement) InertRemove() *InputElement {
	if e.boolAttributes == nil {
		return e
	}
	e.boolAttributes.Del("inert")
	return e
}

// The inputmode global Attribute is an enumerated attribute that hints at the
// type of data that might be entered by the user while editing the element or
// its contents. This allows a browser to display an appropriate virtual
// keyboard. It is used primarily on <input> elements, but is usable on any
// element in contenteditable mode. It's important to understand that the
// inputmode attribute doesn't cause any validity requirements to be enforced on
// input. To require that input conforms to a particular data type, choose an
// appropriate <input> element type. For specific guidance on choosing <input>
// types, see the Values section.
func (e *InputElement) Inputmode(c InputInputmodeChoice) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("inputmode", string(c))
	return e
}

type InputInputmodeChoice string

const (
	// No virtual keyboard. For when the page implements its own keyboard input
	// control.
	InputInputmodeNone InputInputmodeChoice = "none"
	// Standard input keyboard for the user's current locale.
	InputInputmodeEmpty InputInputmodeChoice = ""
	// Standard input keyboard for the user's current locale.
	InputInputmodeText InputInputmodeChoice = "text"
	// Fractional numeric input keyboard containing the digits and decimal separator
	// for the user's locale (typically . or ,). Devices may or may not show a minus
	// key (-).
	InputInputmodeDecimal InputInputmodeChoice = "decimal"
	// Numeric input keyboard, but only requires the digits 09. Devices may or
	// may not show a minus key.
	InputInputmodeNumeric InputInputmodeChoice = "numeric"
	// A telephone keypad input, including the digits 09, the asterisk (*), and
	// the pound (#) key. Inputs that *require* a telephone number should typically
	// use <input type="tel"> instead.
	InputInputmodeTel InputInputmodeChoice = "tel"
	// A virtual keyboard optimized for search input. For instance, the
	// return/submit key may be labeled "Search", along with possible other
	// optimizations. Inputs that require a search query should typically use <input
	// type="search"> instead.
	InputInputmodeSearch InputInputmodeChoice = "search"
	// A virtual keyboard optimized for entering email addresses. Typically includes
	// the @character as well as other optimizations. Inputs that require email
	// addresses should typically use <input type="email"> instead.
	InputInputmodeEmail InputInputmodeChoice = "email"
	// A keypad optimized for entering URLs. This may have the / key more prominent,
	// for example. Enhanced features could include history access and so on. Inputs
	// that require a URL should typically use <input type="url"> instead.
	InputInputmodeURL InputInputmodeChoice = "url"
)

// The inputmode global Attribute is an enumerated attribute that hints at the
// type of data that might be entered by the user while editing the element or
// its contents. This allows a browser to display an appropriate virtual
// keyboard. It is used primarily on <input> elements, but is usable on any
// element in contenteditable mode. It's important to understand that the
// inputmode attribute doesn't cause any validity requirements to be enforced on
// input. To require that input conforms to a particular data type, choose an
// appropriate <input> element type. For specific guidance on choosing <input>
// types, see the Values section.
// Remove the attribute Inputmode from the element.
func (e *InputElement) InputmodeRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("inputmode")
	return e
}

// The is global Attribute allows you to specify that a standard HTML element
// should behave like a defined custom built-in element (see Using custom
// elements for more details). This attribute can only be used if the specified
// custom element name has been successfully defined in the current document,
// and extends the element type it is being applied to.
func (e *InputElement) Is(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("is", s)
	return e
}

// The is global Attribute allows you to specify that a standard HTML element
// should behave like a defined custom built-in element (see Using custom
// elements for more details). This attribute can only be used if the specified
// custom element name has been successfully defined in the current document,
// and extends the element type it is being applied to.
func (e *InputElement) IsF(format string, args ...any) *InputElement {
	return e.Is(fmt.Sprintf(format, args...))
}

// The is global Attribute allows you to specify that a standard HTML element
// should behave like a defined custom built-in element (see Using custom
// elements for more details). This attribute can only be used if the specified
// custom element name has been successfully defined in the current document,
// and extends the element type it is being applied to.
func (e *InputElement) IfIs(condition bool, s string) *InputElement {
	if condition {
		e.Is(s)
	}
	return e
}

// The is global Attribute allows you to specify that a standard HTML element
// should behave like a defined custom built-in element (see Using custom
// elements for more details). This attribute can only be used if the specified
// custom element name has been successfully defined in the current document,
// and extends the element type it is being applied to.
func (e *InputElement) IfIsF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Is(fmt.Sprintf(format, args...))
	}
	return e
}

// The is global Attribute allows you to specify that a standard HTML element
// should behave like a defined custom built-in element (see Using custom
// elements for more details). This attribute can only be used if the specified
// custom element name has been successfully defined in the current document,
// and extends the element type it is being applied to.
// Remove the attribute Is from the element.
func (e *InputElement) IsRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("is")
	return e
}

// The itemid global Attribute provides microdata in the form of a unique,
// global identifier of an item.
//
// An itemid Attribute can only be specified for an element that has both
// itemscope and itemtype attributes. Also, itemid can only be specified on
// elements that possess an itemscope attribute whose corresponding itemtype
// refers to or defines a vocabulary that supports global identifiers. The exact
// meaning of an itemtype's global identifier is provided by the definition of
// that identifier within the specified vocabulary. The vocabulary defines
// whether several items with the same global identifier can coexist and, if so,
// how items with the same identifier are handled.
func (e *InputElement) Itemid(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("itemid", s)
	return e
}

// The itemid global Attribute provides microdata in the form of a unique,
// global identifier of an item.
//
// An itemid Attribute can only be specified for an element that has both
// itemscope and itemtype attributes. Also, itemid can only be specified on
// elements that possess an itemscope attribute whose corresponding itemtype
// refers to or defines a vocabulary that supports global identifiers. The exact
// meaning of an itemtype's global identifier is provided by the definition of
// that identifier within the specified vocabulary. The vocabulary defines
// whether several items with the same global identifier can coexist and, if so,
// how items with the same identifier are handled.
func (e *InputElement) ItemidF(format string, args ...any) *InputElement {
	return e.Itemid(fmt.Sprintf(format, args...))
}

// The itemid global Attribute provides microdata in the form of a unique,
// global identifier of an item.
//
// An itemid Attribute can only be specified for an element that has both
// itemscope and itemtype attributes. Also, itemid can only be specified on
// elements that possess an itemscope attribute whose corresponding itemtype
// refers to or defines a vocabulary that supports global identifiers. The exact
// meaning of an itemtype's global identifier is provided by the definition of
// that identifier within the specified vocabulary. The vocabulary defines
// whether several items with the same global identifier can coexist and, if so,
// how items with the same identifier are handled.
func (e *InputElement) IfItemid(condition bool, s string) *InputElement {
	if condition {
		e.Itemid(s)
	}
	return e
}

// The itemid global Attribute provides microdata in the form of a unique,
// global identifier of an item.
//
// An itemid Attribute can only be specified for an element that has both
// itemscope and itemtype attributes. Also, itemid can only be specified on
// elements that possess an itemscope attribute whose corresponding itemtype
// refers to or defines a vocabulary that supports global identifiers. The exact
// meaning of an itemtype's global identifier is provided by the definition of
// that identifier within the specified vocabulary. The vocabulary defines
// whether several items with the same global identifier can coexist and, if so,
// how items with the same identifier are handled.
func (e *InputElement) IfItemidF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Itemid(fmt.Sprintf(format, args...))
	}
	return e
}

// The itemid global Attribute provides microdata in the form of a unique,
// global identifier of an item.
//
// An itemid Attribute can only be specified for an element that has both
// itemscope and itemtype attributes. Also, itemid can only be specified on
// elements that possess an itemscope attribute whose corresponding itemtype
// refers to or defines a vocabulary that supports global identifiers. The exact
// meaning of an itemtype's global identifier is provided by the definition of
// that identifier within the specified vocabulary. The vocabulary defines
// whether several items with the same global identifier can coexist and, if so,
// how items with the same identifier are handled.
// Remove the attribute Itemid from the element.
func (e *InputElement) ItemidRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("itemid")
	return e
}

// The itemprop global Attribute is used to add properties to an item. Every
// HTML element can have an itemprop attribute specified, and an itemprop
// consists of a name-value pair. Each name-value pair is called a property, and
// a group of one or more properties forms an item. Property values are either a
// string or a URL and can be associated with a very wide range of elements
// including <audio>, <embed>, <iframe>, <img>, <link>, <object>, <source>,
// <track>, and <video>.
func (e *InputElement) Itemprop(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("itemprop", s)
	return e
}

// The itemprop global Attribute is used to add properties to an item. Every
// HTML element can have an itemprop attribute specified, and an itemprop
// consists of a name-value pair. Each name-value pair is called a property, and
// a group of one or more properties forms an item. Property values are either a
// string or a URL and can be associated with a very wide range of elements
// including <audio>, <embed>, <iframe>, <img>, <link>, <object>, <source>,
// <track>, and <video>.
func (e *InputElement) ItempropF(format string, args ...any) *InputElement {
	return e.Itemprop(fmt.Sprintf(format, args...))
}

// The itemprop global Attribute is used to add properties to an item. Every
// HTML element can have an itemprop attribute specified, and an itemprop
// consists of a name-value pair. Each name-value pair is called a property, and
// a group of one or more properties forms an item. Property values are either a
// string or a URL and can be associated with a very wide range of elements
// including <audio>, <embed>, <iframe>, <img>, <link>, <object>, <source>,
// <track>, and <video>.
func (e *InputElement) IfItemprop(condition bool, s string) *InputElement {
	if condition {
		e.Itemprop(s)
	}
	return e
}

// The itemprop global Attribute is used to add properties to an item. Every
// HTML element can have an itemprop attribute specified, and an itemprop
// consists of a name-value pair. Each name-value pair is called a property, and
// a group of one or more properties forms an item. Property values are either a
// string or a URL and can be associated with a very wide range of elements
// including <audio>, <embed>, <iframe>, <img>, <link>, <object>, <source>,
// <track>, and <video>.
func (e *InputElement) IfItempropF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Itemprop(fmt.Sprintf(format, args...))
	}
	return e
}

// The itemprop global Attribute is used to add properties to an item. Every
// HTML element can have an itemprop attribute specified, and an itemprop
// consists of a name-value pair. Each name-value pair is called a property, and
// a group of one or more properties forms an item. Property values are either a
// string or a URL and can be associated with a very wide range of elements
// including <audio>, <embed>, <iframe>, <img>, <link>, <object>, <source>,
// <track>, and <video>.
// Remove the attribute Itemprop from the element.
func (e *InputElement) ItempropRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("itemprop")
	return e
}

// Properties that are not descendants of an element with the itemscope
// Attribute can be associated with an item using the global attribute itemref.
// itemref provides a list of element IDs (not itemids) elsewhere in the
// document, with additional properties The itemref attribute can only be
// specified on elements that have an itemscope attribute specified.
func (e *InputElement) Itemref(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("itemref", s)
	return e
}

// Properties that are not descendants of an element with the itemscope
// Attribute can be associated with an item using the global attribute itemref.
// itemref provides a list of element IDs (not itemids) elsewhere in the
// document, with additional properties The itemref attribute can only be
// specified on elements that have an itemscope attribute specified.
func (e *InputElement) ItemrefF(format string, args ...any) *InputElement {
	return e.Itemref(fmt.Sprintf(format, args...))
}

// Properties that are not descendants of an element with the itemscope
// Attribute can be associated with an item using the global attribute itemref.
// itemref provides a list of element IDs (not itemids) elsewhere in the
// document, with additional properties The itemref attribute can only be
// specified on elements that have an itemscope attribute specified.
func (e *InputElement) IfItemref(condition bool, s string) *InputElement {
	if condition {
		e.Itemref(s)
	}
	return e
}

// Properties that are not descendants of an element with the itemscope
// Attribute can be associated with an item using the global attribute itemref.
// itemref provides a list of element IDs (not itemids) elsewhere in the
// document, with additional properties The itemref attribute can only be
// specified on elements that have an itemscope attribute specified.
func (e *InputElement) IfItemrefF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Itemref(fmt.Sprintf(format, args...))
	}
	return e
}

// Properties that are not descendants of an element with the itemscope
// Attribute can be associated with an item using the global attribute itemref.
// itemref provides a list of element IDs (not itemids) elsewhere in the
// document, with additional properties The itemref attribute can only be
// specified on elements that have an itemscope attribute specified.
// Remove the attribute Itemref from the element.
func (e *InputElement) ItemrefRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("itemref")
	return e
}

// The itemscope global Attribute is used to add an item to a microdata DOM
// tree. Every HTML element can have an itemscope attribute specified, and an
// itemscope consists of a name-value pair. Each name-value pair is called a
// property, and a group of one or more properties forms an item. Property
// values are either a string or a URL and can be associated with a very wide
// range of elements including <audio>, <embed>, <iframe>, <img>, <link>,
// <object>, <source>, <track>, and <video>.
func (e *InputElement) Itemscope() *InputElement {
	e.ItemscopeSet(true)
	return e
}

// The itemscope global Attribute is used to add an item to a microdata DOM
// tree. Every HTML element can have an itemscope attribute specified, and an
// itemscope consists of a name-value pair. Each name-value pair is called a
// property, and a group of one or more properties forms an item. Property
// values are either a string or a URL and can be associated with a very wide
// range of elements including <audio>, <embed>, <iframe>, <img>, <link>,
// <object>, <source>, <track>, and <video>.
func (e *InputElement) IfItemscope(condition bool) *InputElement {
	if condition {
		e.ItemscopeSet(true)
	}
	return e
}

// The itemscope global Attribute is used to add an item to a microdata DOM
// tree. Every HTML element can have an itemscope attribute specified, and an
// itemscope consists of a name-value pair. Each name-value pair is called a
// property, and a group of one or more properties forms an item. Property
// values are either a string or a URL and can be associated with a very wide
// range of elements including <audio>, <embed>, <iframe>, <img>, <link>,
// <object>, <source>, <track>, and <video>.
// Set the attribute Itemscope to the value b explicitly.
func (e *InputElement) ItemscopeSet(b bool) *InputElement {
	if e.boolAttributes == nil {
		e.boolAttributes = treemap.New[string, bool]()
	}
	e.boolAttributes.Set("itemscope", b)
	return e
}

// The itemscope global Attribute is used to add an item to a microdata DOM
// tree. Every HTML element can have an itemscope attribute specified, and an
// itemscope consists of a name-value pair. Each name-value pair is called a
// property, and a group of one or more properties forms an item. Property
// values are either a string or a URL and can be associated with a very wide
// range of elements including <audio>, <embed>, <iframe>, <img>, <link>,
// <object>, <source>, <track>, and <video>.
func (e *InputElement) IfSetItemscope(condition bool, b bool) *InputElement {
	if condition {
		e.ItemscopeSet(b)
	}
	return e
}

// Remove the attribute Itemscope from the element.
// The itemscope global Attribute is used to add an item to a microdata DOM
// tree. Every HTML element can have an itemscope attribute specified, and an
// itemscope consists of a name-value pair. Each name-value pair is called a
// property, and a group of one or more properties forms an item. Property
// values are either a string or a URL and can be associated with a very wide
// range of elements including <audio>, <embed>, <iframe>, <img>, <link>,
// <object>, <source>, <track>, and <video>.
func (e *InputElement) ItemscopeRemove() *InputElement {
	if e.boolAttributes == nil {
		return e
	}
	e.boolAttributes.Del("itemscope")
	return e
}

// The itemtype global Attribute is used to add types to an item. Every HTML
// element can have an itemtype attribute specified, and an itemtype consists of
// a name-value pair. Each name-value pair is called a property, and a group of
// one or more properties forms an item. Property values are either a string or
// a URL and can be associated with a very wide range of elements including
// <audio>, <embed>, <iframe>, <img>, <link>, <object>, <source>, <track>, and
// <video>.
func (e *InputElement) Itemtype(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("itemtype", s)
	return e
}

// The itemtype global Attribute is used to add types to an item. Every HTML
// element can have an itemtype attribute specified, and an itemtype consists of
// a name-value pair. Each name-value pair is called a property, and a group of
// one or more properties forms an item. Property values are either a string or
// a URL and can be associated with a very wide range of elements including
// <audio>, <embed>, <iframe>, <img>, <link>, <object>, <source>, <track>, and
// <video>.
func (e *InputElement) ItemtypeF(format string, args ...any) *InputElement {
	return e.Itemtype(fmt.Sprintf(format, args...))
}

// The itemtype global Attribute is used to add types to an item. Every HTML
// element can have an itemtype attribute specified, and an itemtype consists of
// a name-value pair. Each name-value pair is called a property, and a group of
// one or more properties forms an item. Property values are either a string or
// a URL and can be associated with a very wide range of elements including
// <audio>, <embed>, <iframe>, <img>, <link>, <object>, <source>, <track>, and
// <video>.
func (e *InputElement) IfItemtype(condition bool, s string) *InputElement {
	if condition {
		e.Itemtype(s)
	}
	return e
}

// The itemtype global Attribute is used to add types to an item. Every HTML
// element can have an itemtype attribute specified, and an itemtype consists of
// a name-value pair. Each name-value pair is called a property, and a group of
// one or more properties forms an item. Property values are either a string or
// a URL and can be associated with a very wide range of elements including
// <audio>, <embed>, <iframe>, <img>, <link>, <object>, <source>, <track>, and
// <video>.
func (e *InputElement) IfItemtypeF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Itemtype(fmt.Sprintf(format, args...))
	}
	return e
}

// The itemtype global Attribute is used to add types to an item. Every HTML
// element can have an itemtype attribute specified, and an itemtype consists of
// a name-value pair. Each name-value pair is called a property, and a group of
// one or more properties forms an item. Property values are either a string or
// a URL and can be associated with a very wide range of elements including
// <audio>, <embed>, <iframe>, <img>, <link>, <object>, <source>, <track>, and
// <video>.
// Remove the attribute Itemtype from the element.
func (e *InputElement) ItemtypeRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("itemtype")
	return e
}

// The lang global Attribute helps define the language of an element: the
// language that non-editable elements are written in or the language that
// editable elements should be written in by the user. The tag contains one
// single entry value in the format defines in the Tags for Identifying
// Languages (BCP47) IETF document. xml:lang has priority over it.
func (e *InputElement) Lang(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("lang", s)
	return e
}

// The lang global Attribute helps define the language of an element: the
// language that non-editable elements are written in or the language that
// editable elements should be written in by the user. The tag contains one
// single entry value in the format defines in the Tags for Identifying
// Languages (BCP47) IETF document. xml:lang has priority over it.
func (e *InputElement) LangF(format string, args ...any) *InputElement {
	return e.Lang(fmt.Sprintf(format, args...))
}

// The lang global Attribute helps define the language of an element: the
// language that non-editable elements are written in or the language that
// editable elements should be written in by the user. The tag contains one
// single entry value in the format defines in the Tags for Identifying
// Languages (BCP47) IETF document. xml:lang has priority over it.
func (e *InputElement) IfLang(condition bool, s string) *InputElement {
	if condition {
		e.Lang(s)
	}
	return e
}

// The lang global Attribute helps define the language of an element: the
// language that non-editable elements are written in or the language that
// editable elements should be written in by the user. The tag contains one
// single entry value in the format defines in the Tags for Identifying
// Languages (BCP47) IETF document. xml:lang has priority over it.
func (e *InputElement) IfLangF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Lang(fmt.Sprintf(format, args...))
	}
	return e
}

// The lang global Attribute helps define the language of an element: the
// language that non-editable elements are written in or the language that
// editable elements should be written in by the user. The tag contains one
// single entry value in the format defines in the Tags for Identifying
// Languages (BCP47) IETF document. xml:lang has priority over it.
// Remove the attribute Lang from the element.
func (e *InputElement) LangRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("lang")
	return e
}

// The nonce global Attribute is a unique identifier used to declare inline
// scripts and style elements to be used in a specific document. It is a
// cryptographic nonce (number used once) that is used by Content Security
// Policy to determine whether or not a given inline script is allowed to
// execute.
func (e *InputElement) Nonce(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("nonce", s)
	return e
}

// The nonce global Attribute is a unique identifier used to declare inline
// scripts and style elements to be used in a specific document. It is a
// cryptographic nonce (number used once) that is used by Content Security
// Policy to determine whether or not a given inline script is allowed to
// execute.
func (e *InputElement) NonceF(format string, args ...any) *InputElement {
	return e.Nonce(fmt.Sprintf(format, args...))
}

// The nonce global Attribute is a unique identifier used to declare inline
// scripts and style elements to be used in a specific document. It is a
// cryptographic nonce (number used once) that is used by Content Security
// Policy to determine whether or not a given inline script is allowed to
// execute.
func (e *InputElement) IfNonce(condition bool, s string) *InputElement {
	if condition {
		e.Nonce(s)
	}
	return e
}

// The nonce global Attribute is a unique identifier used to declare inline
// scripts and style elements to be used in a specific document. It is a
// cryptographic nonce (number used once) that is used by Content Security
// Policy to determine whether or not a given inline script is allowed to
// execute.
func (e *InputElement) IfNonceF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Nonce(fmt.Sprintf(format, args...))
	}
	return e
}

// The nonce global Attribute is a unique identifier used to declare inline
// scripts and style elements to be used in a specific document. It is a
// cryptographic nonce (number used once) that is used by Content Security
// Policy to determine whether or not a given inline script is allowed to
// execute.
// Remove the attribute Nonce from the element.
func (e *InputElement) NonceRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("nonce")
	return e
}

// The part global Attribute contains a space-separated list of the part names
// of the element. Part names allows CSS to select and style specific elements
// in a shadow tree via the ::part pseudo-element.
func (e *InputElement) Part(s string) *InputElement {
	values := strings.Split(s, " ")
	if e.delimitedStrings == nil {
		e.delimitedStrings = treemap.New[string, *delimitedBuilder[string]]()
	}
	ds, ok := e.delimitedStrings.Get("part")
	if !ok {
		ds = newDelimitedBuilder[string](" ")
		e.delimitedStrings.Set("part", ds)
	}
	ds.Add(values...)
	return e
}

// The part global Attribute contains a space-separated list of the part names
// of the element. Part names allows CSS to select and style specific elements
// in a shadow tree via the ::part pseudo-element.
func (e *InputElement) IfPart(condition bool, s string) *InputElement {
	if condition {
		e.Part(s)
	}
	return e
}

// The part global Attribute contains a space-separated list of the part names
// of the element. Part names allows CSS to select and style specific elements
// in a shadow tree via the ::part pseudo-element.
// Remove the values from the attribute Part in the element.
func (e *InputElement) PartRemove(s ...string) *InputElement {
	if e.delimitedStrings == nil {
		return e
	}
	ds, ok := e.delimitedStrings.Get("part")
	if !ok {
		return e
	}
	ds.Remove(s...)
	return e
}

// The popover global Attribute is used to designate an element as a popover
// element. Popover elements are hidden via display: none until opened via an
// invoking/control element (i.e. a <button> or <input type="button"> with a
// popovertarget attribute) or a HTMLElement.showPopover() call. When open,
// popover elements will appear above all other elements in the top layer, and
// won't be influenced by parent elements' position or overflow styling.
func (e *InputElement) Popover(c InputPopoverChoice) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("popover", string(c))
	return e
}

type InputPopoverChoice string

const (
	// Popovers that have the auto state can be "light dismissed" by selecting
	// outside the popover area, and generally only allow one popover to be
	// displayed on-screen at a time.
	InputPopoverAuto InputPopoverChoice = "auto"
	// Popovers that have the auto state can be "light dismissed" by selecting
	// outside the popover area, and generally only allow one popover to be
	// displayed on-screen at a time.
	InputPopoverEmpty InputPopoverChoice = ""
	// manual popovers must always be explicitly hidden, but allow for use cases
	// such as nested popovers in menus.
	InputPopoverManual InputPopoverChoice = "manual"
)

// The popover global Attribute is used to designate an element as a popover
// element. Popover elements are hidden via display: none until opened via an
// invoking/control element (i.e. a <button> or <input type="button"> with a
// popovertarget attribute) or a HTMLElement.showPopover() call. When open,
// popover elements will appear above all other elements in the top layer, and
// won't be influenced by parent elements' position or overflow styling.
// Remove the attribute Popover from the element.
func (e *InputElement) PopoverRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("popover")
	return e
}

// The role global Attribute is used to define the purpose or state of an
// element to the browser, in order to facilitate assistive technology such as
// screen readers. It is a simple string value that can be used to describe the
// role of an element.
func (e *InputElement) Role(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("role", s)
	return e
}

// The role global Attribute is used to define the purpose or state of an
// element to the browser, in order to facilitate assistive technology such as
// screen readers. It is a simple string value that can be used to describe the
// role of an element.
func (e *InputElement) RoleF(format string, args ...any) *InputElement {
	return e.Role(fmt.Sprintf(format, args...))
}

// The role global Attribute is used to define the purpose or state of an
// element to the browser, in order to facilitate assistive technology such as
// screen readers. It is a simple string value that can be used to describe the
// role of an element.
func (e *InputElement) IfRole(condition bool, s string) *InputElement {
	if condition {
		e.Role(s)
	}
	return e
}

// The role global Attribute is used to define the purpose or state of an
// element to the browser, in order to facilitate assistive technology such as
// screen readers. It is a simple string value that can be used to describe the
// role of an element.
func (e *InputElement) IfRoleF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Role(fmt.Sprintf(format, args...))
	}
	return e
}

// The role global Attribute is used to define the purpose or state of an
// element to the browser, in order to facilitate assistive technology such as
// screen readers. It is a simple string value that can be used to describe the
// role of an element.
// Remove the attribute Role from the element.
func (e *InputElement) RoleRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("role")
	return e
}

// The slot global Attribute assigns a slot in a shadow DOM shadow tree to an
// element: An element with a slot attribute is assigned to the slot created by
// the <slot> element whose name attribute's value matches that slot attribute's
// value.
func (e *InputElement) Slot(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("slot", s)
	return e
}

// The slot global Attribute assigns a slot in a shadow DOM shadow tree to an
// element: An element with a slot attribute is assigned to the slot created by
// the <slot> element whose name attribute's value matches that slot attribute's
// value.
func (e *InputElement) SlotF(format string, args ...any) *InputElement {
	return e.Slot(fmt.Sprintf(format, args...))
}

// The slot global Attribute assigns a slot in a shadow DOM shadow tree to an
// element: An element with a slot attribute is assigned to the slot created by
// the <slot> element whose name attribute's value matches that slot attribute's
// value.
func (e *InputElement) IfSlot(condition bool, s string) *InputElement {
	if condition {
		e.Slot(s)
	}
	return e
}

// The slot global Attribute assigns a slot in a shadow DOM shadow tree to an
// element: An element with a slot attribute is assigned to the slot created by
// the <slot> element whose name attribute's value matches that slot attribute's
// value.
func (e *InputElement) IfSlotF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Slot(fmt.Sprintf(format, args...))
	}
	return e
}

// The slot global Attribute assigns a slot in a shadow DOM shadow tree to an
// element: An element with a slot attribute is assigned to the slot created by
// the <slot> element whose name attribute's value matches that slot attribute's
// value.
// Remove the attribute Slot from the element.
func (e *InputElement) SlotRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("slot")
	return e
}

// The spellcheck global Attribute is an enumerated attribute that defines
// whether the element may be checked for spelling errors. If this attribute is
// not set, its default value is element-type and browser-defined. This default
// value may also be inherited, which means that the element content will be
// checked for spelling errors only if its nearest ancestor has a spellcheck
// state of true. Security and privacy concerns Using spellchecking can have
// consequences for users' security and privacy. The specification does not
// regulate how spellchecking is done and the content of the element may be sent
// to a third party for spellchecking results (see enhanced spellchecking and
// "spell-jacking"). You should consider setting spellcheck to false for
// elements that can contain sensitive information.
func (e *InputElement) Spellcheck(c InputSpellcheckChoice) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("spellcheck", string(c))
	return e
}

type InputSpellcheckChoice string

const (
	// The element will be checked for spelling errors.
	InputSpellcheckEmpty InputSpellcheckChoice = ""
	// The element will be checked for spelling errors.
	InputSpellcheckTrue InputSpellcheckChoice = "true"
	// The element will not be checked for spelling errors.
	InputSpellcheckFalse InputSpellcheckChoice = "false"
)

// The spellcheck global Attribute is an enumerated attribute that defines
// whether the element may be checked for spelling errors. If this attribute is
// not set, its default value is element-type and browser-defined. This default
// value may also be inherited, which means that the element content will be
// checked for spelling errors only if its nearest ancestor has a spellcheck
// state of true. Security and privacy concerns Using spellchecking can have
// consequences for users' security and privacy. The specification does not
// regulate how spellchecking is done and the content of the element may be sent
// to a third party for spellchecking results (see enhanced spellchecking and
// "spell-jacking"). You should consider setting spellcheck to false for
// elements that can contain sensitive information.
// Remove the attribute Spellcheck from the element.
func (e *InputElement) SpellcheckRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("spellcheck")
	return e
}

// The style global Attribute is used to add styles to an element, such as
// color, font, size, and more. Styles are written in CSS.
func (e *InputElement) StylePairs(pairs ...string) *InputElement {
	if len(pairs) == 0 || len(pairs)%2 != 0 {
		panic("StylePairs requires an even number of arguments representing key-value pairs.")
	}
	if e.keyValueStrings == nil {
		e.keyValueStrings = treemap.New[string, *keyValueBuilder]()
	}
	kv, ok := e.keyValueStrings.Get("style")
	if !ok {
		kv = newKVBuilder(":", ";")
		e.keyValueStrings.Set("style", kv)
	}
	for i := 0; i < len(pairs)-1; i += 2 {
		key := strings.TrimSpace(pairs[i])
		if key == "" {
			panic("empty key in key-value pairs.")
		}
		value := strings.TrimSpace(pairs[i+1])
		kv.Add(key, value)
	}
	return e
}

// The style global Attribute is used to add styles to an element, such as
// color, font, size, and more. Styles are written in CSS.
func (e *InputElement) Style(s string) *InputElement {
	if e.keyValueStrings == nil {
		e.keyValueStrings = treemap.New[string, *keyValueBuilder]()
	}
	_, ok := e.keyValueStrings.Get("style")
	if !ok {
		kv := newKVBuilder(":", ";")
		e.keyValueStrings.Set("style", kv)
	}
	s = strings.TrimRight(s, ";")
	kvPairs := strings.Split(s, ";")
	for _, pair := range kvPairs {
		parts := strings.SplitN(pair, ":", 2)
		if len(parts) != 2 {
			panic(fmt.Sprintf("invalid key-value pair: %q", pair))
		}
		e.StylePairs(parts[0], parts[1])
	}
	return e
}

// The style global Attribute is used to add styles to an element, such as
// color, font, size, and more. Styles are written in CSS.
func (e *InputElement) IfStyle(condition bool, s string) *InputElement {
	if condition {
		e.Style(s)
	}
	return e
}

// The style global Attribute is used to add styles to an element, such as
// color, font, size, and more. Styles are written in CSS.
func (e *InputElement) StyleAdd(k string, v string) *InputElement {
	if e.keyValueStrings == nil {
		e.keyValueStrings = treemap.New[string, *keyValueBuilder]()
	}
	_, ok := e.keyValueStrings.Get("style")
	if !ok {
		kv := newKVBuilder(":", ";")
		e.keyValueStrings.Set("style", kv)
	}
	e.StylePairs(k, v)
	return e
}

// The style global Attribute is used to add styles to an element, such as
// color, font, size, and more. Styles are written in CSS.
func (e *InputElement) StyleAddF(k string, format string, args ...any) *InputElement {
	return e.StyleAdd(k, fmt.Sprintf(format, args...))
}

// The style global Attribute is used to add styles to an element, such as
// color, font, size, and more. Styles are written in CSS.
func (e *InputElement) IfStyleAdd(condition bool, k string, v string) *InputElement {
	if condition {
		e.StyleAdd(k, v)
	}
	return e
}

// The style global Attribute is used to add styles to an element, such as
// color, font, size, and more. Styles are written in CSS.
func (e *InputElement) IfStyleAddF(condition bool, k string, format string, args ...any) *InputElement {
	if condition {
		e.StyleAddF(k, format, args...)
	}
	return e
}

// The style global Attribute is used to add styles to an element, such as
// color, font, size, and more. Styles are written in CSS.
// Add the attributes in the map to the element.
func (e *InputElement) StyleMap(m map[string]string) *InputElement {
	if e.keyValueStrings == nil {
		e.keyValueStrings = treemap.New[string, *keyValueBuilder]()
	}
	_, ok := e.keyValueStrings.Get("style")
	if !ok {
		kv := newKVBuilder(":", ";")
		e.keyValueStrings.Set("style", kv)
	}
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		e.StylePairs(k, m[k])
	}
	return e
}

// The style global Attribute is used to add styles to an element, such as
// color, font, size, and more. Styles are written in CSS.
// Remove the attribute Style from the element.
func (e *InputElement) StyleRemove(keys ...string) *InputElement {
	if e.keyValueStrings == nil {
		return e
	}
	kv, ok := e.keyValueStrings.Get("style")
	if !ok {
		return e
	}
	kv.Remove(keys...)
	return e
}

// The tabindex global Attribute indicates if its element can be focused, and
// if/where it participates in sequential keyboard navigation (usually with the
// Tab key, hence the name). It accepts an integer as a value, with different
// results depending on the integer's value: a negative value (usually
// tabindex="-1") means that the element should be focusable, but should not be
// reachable via sequential keyboard navigation; a value of 0 (tabindex="0")
// means that the element should be focusable and reachable via sequential
// keyboard navigation, but its relative order is defined by the platform
// convention; a positive value means should be focusable and reachable via
// sequential keyboard navigation; its relative order is defined by the value of
// the attribute: the sequential follow the increasing number of the tabindex.
// If several elements share the same tabindex, their relative order follows
// their relative position in the document.
func (e *InputElement) Tabindex(i int) *InputElement {
	if e.intAttributes == nil {
		e.intAttributes = treemap.New[string, int]()
	}
	e.intAttributes.Set("tabindex", i)
	return e
}

// The tabindex global Attribute indicates if its element can be focused, and
// if/where it participates in sequential keyboard navigation (usually with the
// Tab key, hence the name). It accepts an integer as a value, with different
// results depending on the integer's value: a negative value (usually
// tabindex="-1") means that the element should be focusable, but should not be
// reachable via sequential keyboard navigation; a value of 0 (tabindex="0")
// means that the element should be focusable and reachable via sequential
// keyboard navigation, but its relative order is defined by the platform
// convention; a positive value means should be focusable and reachable via
// sequential keyboard navigation; its relative order is defined by the value of
// the attribute: the sequential follow the increasing number of the tabindex.
// If several elements share the same tabindex, their relative order follows
// their relative position in the document.
func (e *InputElement) IfTabindex(condition bool, i int) *InputElement {
	if condition {
		e.Tabindex(i)
	}
	return e
}

// The tabindex global Attribute indicates if its element can be focused, and
// if/where it participates in sequential keyboard navigation (usually with the
// Tab key, hence the name). It accepts an integer as a value, with different
// results depending on the integer's value: a negative value (usually
// tabindex="-1") means that the element should be focusable, but should not be
// reachable via sequential keyboard navigation; a value of 0 (tabindex="0")
// means that the element should be focusable and reachable via sequential
// keyboard navigation, but its relative order is defined by the platform
// convention; a positive value means should be focusable and reachable via
// sequential keyboard navigation; its relative order is defined by the value of
// the attribute: the sequential follow the increasing number of the tabindex.
// If several elements share the same tabindex, their relative order follows
// their relative position in the document.
// Remove the attribute Tabindex from the element.
func (e *InputElement) TabindexRemove() *InputElement {
	if e.intAttributes == nil {
		return e
	}
	e.intAttributes.Del("tabindex")
	return e
}

// The title global Attribute contains text representing advisory information
// related to the element it belongs to. Such information can typically, but not
// necessarily, be presented to the user as a tooltip. The main use of the title
// attribute is to label <iframe> elements for assistive technology. The title
// attribute may also be used to label controls in data tables. The title
// attribute, when added to <link rel="stylesheet">, creates an alternate
// stylesheet. When defining an alternative style sheet with <link
// rel="alternate"> the attribute is required and must be set to a non-empty
// string. If included on the <abbr> opening tag, the title must be a full
// expansion of the abbreviation or acronym. Instead of using title, when
// possible, provide an expansion of the abbreviation or acronym in plain text
// on first use, using the <abbr> to mark up the abbreviation. This enables all
// users know what name or term the abbreviation or acronym shortens while
// providing a hint to user agents on how to announce the content. While title
// can be used to provide a programmatically associated label for an <input>
// element, this is not good practice. Use a <label> instead.
func (e *InputElement) Title(s string) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("title", s)
	return e
}

// The title global Attribute contains text representing advisory information
// related to the element it belongs to. Such information can typically, but not
// necessarily, be presented to the user as a tooltip. The main use of the title
// attribute is to label <iframe> elements for assistive technology. The title
// attribute may also be used to label controls in data tables. The title
// attribute, when added to <link rel="stylesheet">, creates an alternate
// stylesheet. When defining an alternative style sheet with <link
// rel="alternate"> the attribute is required and must be set to a non-empty
// string. If included on the <abbr> opening tag, the title must be a full
// expansion of the abbreviation or acronym. Instead of using title, when
// possible, provide an expansion of the abbreviation or acronym in plain text
// on first use, using the <abbr> to mark up the abbreviation. This enables all
// users know what name or term the abbreviation or acronym shortens while
// providing a hint to user agents on how to announce the content. While title
// can be used to provide a programmatically associated label for an <input>
// element, this is not good practice. Use a <label> instead.
func (e *InputElement) TitleF(format string, args ...any) *InputElement {
	return e.Title(fmt.Sprintf(format, args...))
}

// The title global Attribute contains text representing advisory information
// related to the element it belongs to. Such information can typically, but not
// necessarily, be presented to the user as a tooltip. The main use of the title
// attribute is to label <iframe> elements for assistive technology. The title
// attribute may also be used to label controls in data tables. The title
// attribute, when added to <link rel="stylesheet">, creates an alternate
// stylesheet. When defining an alternative style sheet with <link
// rel="alternate"> the attribute is required and must be set to a non-empty
// string. If included on the <abbr> opening tag, the title must be a full
// expansion of the abbreviation or acronym. Instead of using title, when
// possible, provide an expansion of the abbreviation or acronym in plain text
// on first use, using the <abbr> to mark up the abbreviation. This enables all
// users know what name or term the abbreviation or acronym shortens while
// providing a hint to user agents on how to announce the content. While title
// can be used to provide a programmatically associated label for an <input>
// element, this is not good practice. Use a <label> instead.
func (e *InputElement) IfTitle(condition bool, s string) *InputElement {
	if condition {
		e.Title(s)
	}
	return e
}

// The title global Attribute contains text representing advisory information
// related to the element it belongs to. Such information can typically, but not
// necessarily, be presented to the user as a tooltip. The main use of the title
// attribute is to label <iframe> elements for assistive technology. The title
// attribute may also be used to label controls in data tables. The title
// attribute, when added to <link rel="stylesheet">, creates an alternate
// stylesheet. When defining an alternative style sheet with <link
// rel="alternate"> the attribute is required and must be set to a non-empty
// string. If included on the <abbr> opening tag, the title must be a full
// expansion of the abbreviation or acronym. Instead of using title, when
// possible, provide an expansion of the abbreviation or acronym in plain text
// on first use, using the <abbr> to mark up the abbreviation. This enables all
// users know what name or term the abbreviation or acronym shortens while
// providing a hint to user agents on how to announce the content. While title
// can be used to provide a programmatically associated label for an <input>
// element, this is not good practice. Use a <label> instead.
func (e *InputElement) IfTitleF(condition bool, format string, args ...any) *InputElement {
	if condition {
		e.Title(fmt.Sprintf(format, args...))
	}
	return e
}

// The title global Attribute contains text representing advisory information
// related to the element it belongs to. Such information can typically, but not
// necessarily, be presented to the user as a tooltip. The main use of the title
// attribute is to label <iframe> elements for assistive technology. The title
// attribute may also be used to label controls in data tables. The title
// attribute, when added to <link rel="stylesheet">, creates an alternate
// stylesheet. When defining an alternative style sheet with <link
// rel="alternate"> the attribute is required and must be set to a non-empty
// string. If included on the <abbr> opening tag, the title must be a full
// expansion of the abbreviation or acronym. Instead of using title, when
// possible, provide an expansion of the abbreviation or acronym in plain text
// on first use, using the <abbr> to mark up the abbreviation. This enables all
// users know what name or term the abbreviation or acronym shortens while
// providing a hint to user agents on how to announce the content. While title
// can be used to provide a programmatically associated label for an <input>
// element, this is not good practice. Use a <label> instead.
// Remove the attribute Title from the element.
func (e *InputElement) TitleRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("title")
	return e
}

// The translate global Attribute is an enumerated attribute that is used to
// specify whether an element's attribute values and the values of its Text node
// children are to be translated when the page is localized, or whether to leave
// them unchanged.
func (e *InputElement) Translate(c InputTranslateChoice) *InputElement {
	if e.stringAttributes == nil {
		e.stringAttributes = treemap.New[string, string]()
	}
	e.stringAttributes.Set("translate", string(c))
	return e
}

type InputTranslateChoice string

const (
	// indicates that the element should be translated when the page is localized.
	InputTranslateEmpty InputTranslateChoice = ""
	// indicates that the element should be translated when the page is localized.
	InputTranslateYes InputTranslateChoice = "yes"
	// indicates that the element must not be translated when the page is localized.
	InputTranslateNo InputTranslateChoice = "no"
)

// The translate global Attribute is an enumerated attribute that is used to
// specify whether an element's attribute values and the values of its Text node
// children are to be translated when the page is localized, or whether to leave
// them unchanged.
// Remove the attribute Translate from the element.
func (e *InputElement) TranslateRemove() *InputElement {
	if e.stringAttributes == nil {
		return e
	}
	e.stringAttributes.Del("translate")
	return e
}
